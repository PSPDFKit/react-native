/**
 * @class DocumentJSON
 * @ignore
 * @memberof Annotation
 * @property {AnnotationType[]} [annotations] Array of annotations.
 * @property {any[]} [formFields] Array of form fields.
 * @property {string} [format] Format of the Instant JSON.
 * @property {Object.<string, AnnotationAttachment>} [attachments] Annotation attachments.
 * @property {Object.<string, string>} [pdfId] PDF identifier.
 * @property {Object.<string, any>} [metadata] Metadata.
 * @property {number[]} [skippedPdfObjectIds] Skipped PDF object IDs.
 */
/**
 * @class AnnotationAttachment
 * @ignore
 * @memberof Annotation
 * @property {string} [binary] Binary data as base64 string.
 * @property {string} [contentType] MIME type.
 * @property {string} [fileName] File name.
 * @property {string} [description] Description.
 */
/**
 * @class BaseAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} [uuid] Unique identifier generated by Nutrient
 * @property {string} [id] Unique identifier
 * @property {string} [name] Name identifier
 * @property {string} [createdAt] Creation date in ISO format
 * @property {string} [updatedAt] Last update date in ISO format
 * @property {string} [creatorName] Creator name
 * @property {number[]} bbox Position on page [left, top, width, height]
 * @property {number} pageIndex Zero-based page index where annotation is placed
 * @property {number} opacity Opacity value between 0 and 1. Default: 1
 * @property {number} [pdfObjectId] PDF object identifier. Default: null
 * @property {string} type Annotation type identifier
 * @property {Array<string>} [flags] Annotation flags
 * @property {number} v Version number. Default: 1
 * @property {Object} [customData] Custom metadata
 * @property {string} blendMode Blend mode. Default: "normal"
 * @property {boolean} [hidden] Whether annotation is hidden. Default: false
 * @property {boolean} [locked] Whether annotation is locked. Default: false
 * @property {boolean} [lockedContents] Whether contents are locked. Default: false
 * @property {boolean} [noPrint] Whether annotation can be printed. Default: false
 * @property {boolean} [noView] Whether annotation is visible. Default: false
 * @property {boolean} [readOnly] Whether annotation is read only. Default: false
 */
/**
 * @class CommentMarkerAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/comment-marker"
 * @property {string} [color] Color in hex format
 */
/**
 * @class ShapeEllipseAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/shape/ellipse"
 * @property {number[]} [cloudyBorderInset] Border inset [left, top, right, bottom]
 * @property {number} [cloudyBorderIntensity] Border cloudiness intensity
 */
/**
 * @class MarkupHighlightAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/markup/highlight"
 * @property {string} color Highlight color
 * @property {number[]} rects Rectangle coordinates for highlighted areas
 */
/**
 * @class ImageAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/image"
 * @property {string} [contentType] Image MIME type
 * @property {string} [description] Image description
 * @property {string} [fileName] Image file name
 * @property {string} [imageAttachmentId] Attachment identifier
 * @property {boolean} [isSignature] Whether image is a signature. Default: false
 * @property {number} [rotation] Rotation angle in degrees. Default: 0
 */
/**
 * @class InkAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/ink"
 * @property {Object} [lines] Ink strokes.
 * @property {Array<Array<any>>} [lines.points] Points arrays.
 * @property {Array<Array<number>>} [lines.intensities] Pressure values.
 * @property {number} lineWidth Stroke width. Default: 5
 * @property {string} [strokeColor] Stroke color. Default: "#0000FF"
 * @property {boolean} isDrawnNaturally Whether drawn by hand. Default: false
 * @property {boolean} [isSignature] Whether ink is a signature. Default: false
 * @property {string} [backgroundColor] Background color
 */
/**
 * @class LineShapeAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier.
 * @property {number[]} [startPoint] Line start point.
 * @property {number[]} [endPoint] Line end point.
 * @property {Object} [lineCaps] Line end styles.
 */
/**
 * @class LinkAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier.
 * @property {Object} [action] Link action.
 * @property {string} [borderColor] Border color.
 * @property {string} [borderStyle] Border style.
 * @property {number} [borderWidth] Border width.
 * @property {string} [note] Link note.
 */
/**
 * @class MarkupAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Markup type identifier
 * @property {string} color Color in hex format
 * @property {Array<any>} rects Rectangle coordinates [left, top, right, bottom]
 * @property {string} [note] Note text
 */
/**
 * @class MediaAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/media"
 * @property {string} [contentType] Media MIME type
 * @property {string} [fileName] Media file name
 * @property {string} mediaAttachmentId Media attachment ID
 * @property {string} [posterImageAttachmentId] Poster image ID
 * @property {boolean} [autoplay] Auto-play media. Default: false
 * @property {boolean} [showControls] Show media controls. Default: true
 * @property {boolean} [repeat] Loop media. Default: false
 * @property {number} [volume] Media volume. Default: 1
 * @property {number} [offset] Time offset. Default: 0
 * @property {string} [mediaSource] Media source type
 * @property {Object} [encoding] Audio encoding settings
 */
/**
 * @class NoteAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/note"
 * @property {string} [color] Note color
 * @property {string} [icon] Note icon type
 * @property {(string|Object)} [text] Text content.
 */
/**
 * @class ShapeAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Shape type identifier
 * @property {string} [fillColor] Fill color in hex format
 * @property {string} [strokeColor] Stroke color in hex format
 * @property {number} [strokeWidth] Stroke width in points
 * @property {number[]} [strokeDashArray] Dash pattern [dash, gap]
 * @property {number} [cloudyBorderIntensity] Border cloudiness intensity
 * @property {string} [note] Note text
 * @property {Object} [measurementScale] Scale for measurements
 * @property {string} [measurementPrecision] Measurement precision
 * @property {number[]} [measurementBBox] Measurement bounding box
 */
/**
 * @class SquigglyMarkupAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/markup/squiggly"
 */
/**
 * @class RedactionMarkupAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/markup/redaction"
 * @property {string} [fillColor] Fill color in hex format
 * @property {string} [overlayText] Text to display over redaction
 * @property {boolean} [repeatOverlayText] Whether to repeat overlay text
 * @property {string} [outlineColor] Outline color in hex format
 * @property {number} [rotation] Rotation angle in degrees. Default: 0
 */
/**
 * @class StampAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/stamp"
 * @property {string} [imageAttachmentId] Image attachment identifier
 * @property {string} [stampType] Predefined stamp type
 * @property {string} [title] Title text
 * @property {string} [subtitle] Subtitle text
 * @property {string} [color] Color in hex format
 * @property {number} [rotation] Rotation angle in degrees. Default: 0
 * @property {string} [subject] Subject text
 * @property {number[]} [size] Size [width, height]
 * @property {number} [scale] Scale factor
 */
/**
 * @class StrikeOutMarkupAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/markup/strikeout"
 */
/**
 * @class TextAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/text"
 * @property {(string|Object)} [text] Text content.
 * @property {string} [fontFamily] Font family name
 * @property {number} fontSize Font size in points
 * @property {string} fontColor Font color in hex format
 * @property {string} [fontWeight] Font weight
 * @property {string[]} [fontStyle] Font style attributes
 * @property {string} [textDecorationLine] Text decoration type
 * @property {string} [textDecorationStyle] Text decoration style
 * @property {string} [textDecorationColor] Decoration color in hex format
 * @property {string} [horizontalAlign] Horizontal alignment
 * @property {string} [verticalAlign] Vertical alignment
 * @property {number} [characterSpacing] Character spacing
 * @property {number} [lineHeight] Line height
 * @property {string} [backgroundColor] Background color in hex format
 * @property {string} [borderStyle] Border style
 * @property {number} [borderWidth] Border width in points
 * @property {number} [rotation] Rotation angle in degrees
 * @property {number} [cloudyBorderIntensity] Border cloudiness intensity
 * @property {number[]} [cloudyBorderInset] Border inset [left, top, right, bottom]
 * @property {boolean} [isFitting] Whether text fits container
 * @property {Object} [callout] Callout properties
 * @property {string} [font] Font name
 */
/**
 * @class UnderlineMarkupAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/markup/underline"
 */
/**
 * @class WidgetAnnotation
 * @ignore
 * @memberof Annotation
 * @property {string} type Type identifier. Default: "pspdfkit/widget"
 * @property {string} horizontalAlign Horizontal alignment. Default: "left"
 * @property {string} verticalAlign Vertical alignment
 * @property {string} [formFieldName] Form field name
 * @property {string} [font] Font name
 * @property {string} [fontColor] Font color in hex format
 * @property {number} [fontSize] Font size in points
 * @property {string} [fieldType] Field type
 * @property {(string|number|boolean)} [fieldValue] Field value
 * @property {(string|number|boolean)} [defaultValue] Default field value
 * @property {string} [placeholder] Placeholder text
 * @property {number} [maxLength] Maximum text length
 * @property {boolean} [isMultiline] Whether field accepts multiple lines
 * @property {boolean} [isPassword] Whether field is password type
 * @property {string[]} [choices] Available choices for choice fields
 * @property {boolean} [isReadOnly] Whether field is read-only
 * @property {boolean} [isRequired] Whether field is required
 * @property {boolean} [isEditable] Whether field is editable
 * @property {number} [rotation] Rotation angle in degrees. Default: 0
 * @property {string} [backgroundColor] Background color in hex format
 * @property {string} [borderColor] Border color in hex format
 * @property {string} [borderStyle] Border style
 * @property {number} [borderWidth] Border width in points
 * @property {Object} [additionalActions] Form field actions
 * @property {boolean} [isBold] Whether text is bold. Default: false
 * @property {boolean} [isItalic] Whether text is italic. Default: false
 * @property {FormElement} [formElement] The form element associated with this widget annotation.
 */

import { FormElement } from "../forms/FormElement";

/**
 * Document JSON wrapper used to construct Document JSON objects.
 * @ignore
 */
export class DocumentJSON {
  annotations?: Array<AnnotationType>;
  formFields?: Array<any>;
  format?: 'https://pspdfkit.com/instant-json/v1';
  attachments?: {
    [key: string]: AnnotationAttachment;
  };
  pdfId?: Record<string, string>;
  metadata?: Record<string, any>;
  skippedPdfObjectIds?: number[];

  constructor() {}
}

/**
 * Annotation attachments used to store images and other attachments.
 * @ignore
 */
export class AnnotationAttachment {
  binary?: string;
  contentType?: string;
  fileName?: string;
  description?: string;

  constructor() {}
}

/**
 * Base interface for all annotation types
 * @ignore
 */
export class BaseAnnotation {
  /** Unique identifier generated by Nutrient */
  uuid?: string;
  /** Unique identifier */
  id?: string;
  /** Name identifier */
  name?: string;
  /** Creation date */
  createdAt?: string;
  /** Last update date */
  updatedAt?: string;
  /** Creator name */
  creatorName?: string;
  /** Position of this annotation on the page */
  bbox: [number, number, number, number];
  /** Page index where the annotation is placed */
  pageIndex: number;
  /** Opacity value between 0 and 1 */
  opacity: number = 1;
  /** PDF object identifier */
  pdfObjectId?: number;
  /** Annotation type */
  type?: string;
  /** Annotation flags */
  flags?: Array<string>;
  /** Version number */
  v: number = 1;
  /** Custom data */
  customData?: Object;
  /** Blend mode */
  blendMode?: string = "normal";
  /** Whether the annotation is hidden */
  hidden?: boolean = false;
  /** Whether the annotation is locked */
  locked?: boolean = false;
  /** Whether the annotation contents are locked */
  lockedContents?: boolean = false;
  /** Whether the annotation can be printed */
  noPrint?: boolean = false;
  /** Whether the annotation is visible */
  noView?: boolean = false;
  /** Whether the annotation is read only */
  readOnly?: boolean = false;
  // Optional annotation subject. This is used to add information.
  subject?: string;
  // Optional PDF Action.
  action?: {
    type?: string;
    [key: string]: any;
  };

  /**
   * @ignore
   */
  constructor(params: {
    // Required properties
    pageIndex: number;
    bbox: [number, number, number, number];
    // Optional properties with defaults
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    // Optional properties
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    type?: string;
    flags?: Array<string>;
    customData?: Object;
    subject?: string;
    action?: {
      type?: string;
      [key: string]: any;
    };
  }) {
    this.pageIndex = params.pageIndex;
    this.bbox = params.bbox;
    this.opacity = params.opacity ?? 1;
    this.v = params.v ?? 1;
    this.blendMode = params.blendMode ?? "normal";
    this.hidden = params.hidden ?? false;
    this.locked = params.locked ?? false;
    this.lockedContents = params.lockedContents ?? false;
    this.noPrint = params.noPrint ?? false;
    this.noView = params.noView ?? false;
    this.readOnly = params.readOnly ?? false;
    this.uuid = params.uuid;
    this.id = params.id;
    this.name = params.name;
    this.createdAt = params.createdAt;
    this.updatedAt = params.updatedAt;
    this.creatorName = params.creatorName;
    this.pdfObjectId = params.pdfObjectId;
    this.type = params.type;
    this.flags = params.flags;
    this.customData = params.customData;
    this.subject = params.subject;
    this.action = params.action;
  }
}

/**
 * Shape annotation base interface
 * @ignore
 */
export class ShapeAnnotation extends BaseAnnotation {
  type: 'pspdfkit/shape/ellipse' | 'shape/ellipse' | 'ellipse' |
         'pspdfkit/shape/rectangle' | 'shape/rectangle' | 'rectangle' |
         'pspdfkit/shape/line' | 'shape/line' | 'line' |
         'pspdfkit/shape/polygon' | 'shape/polygon' | 'polygon' |
         'pspdfkit/shape/polyline' | 'shape/polyline' | 'polyline';
  fillColor?: string;
  strokeColor?: string;
  strokeWidth?: number;
  strokeDashArray?: [number, number];
  cloudyBorderIntensity?: number;
  note?: string;
  measurementScale?: {
    from: number;
    to: number;
    unitFrom: string;
    unitTo: string;
  };
  measurementPrecision?: string;
  measurementBBox?: [number, number, number, number];

  constructor(params: {
    pageIndex: number;
    type: 'pspdfkit/shape/ellipse' | 'shape/ellipse' | 'ellipse' |
    'pspdfkit/shape/rectangle' | 'shape/rectangle' | 'rectangle' |
    'pspdfkit/shape/line' | 'shape/line' | 'line' |
    'pspdfkit/shape/polygon' | 'shape/polygon' | 'polygon' |
    'pspdfkit/shape/polyline' | 'shape/polyline' | 'polyline'
    bbox: [number, number, number, number];
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    fillColor?: string;
    strokeColor?: string;
    strokeWidth?: number;
    strokeDashArray?: [number, number];
    cloudyBorderIntensity?: number;
    note?: string;
    measurementScale?: {
      from: number;
      to: number;
      unitFrom: string;
      unitTo: string;
    };
    measurementPrecision?: string;
    measurementBBox?: [number, number, number, number];
  }) {
    super(params);
    this.type = params.type;
    this.fillColor = params.fillColor;
    this.strokeColor = params.strokeColor;
    this.strokeWidth = params.strokeWidth;
    this.strokeDashArray = params.strokeDashArray;
    this.cloudyBorderIntensity = params.cloudyBorderIntensity;
    this.note = params.note;
    this.measurementScale = params.measurementScale;
    this.measurementPrecision = params.measurementPrecision;
    this.measurementBBox = params.measurementBBox;
  }
}

/**
 * Markup annotation base interface
 * @ignore
 */
export class MarkupAnnotation extends BaseAnnotation {
  type: 'pspdfkit/markup/highlight' | 'markup/highlight' | 'highlight' |
        'pspdfkit/markup/redaction' | 'markup/redaction' | 'redaction' |
        'pspdfkit/markup/squiggly' | 'markup/squiggly' | 'squiggly' |
        'pspdfkit/markup/strikeout' | 'markup/strikeout' | 'strikeout' |
        'pspdfkit/markup/underline' | 'markup/underline' | 'underline';
  color: string;
  rects: Array<[number, number, number, number]>;
  note?: string;

  constructor(params: {
    pageIndex: number;
    type: 'pspdfkit/markup/highlight' | 'markup/highlight' | 'highlight' |
        'pspdfkit/markup/redaction' | 'markup/redaction' | 'redaction' |
        'pspdfkit/markup/squiggly' | 'markup/squiggly' | 'squiggly' |
        'pspdfkit/markup/strikeout' | 'markup/strikeout' | 'strikeout' |
        'pspdfkit/markup/underline' | 'markup/underline' | 'underline'
    bbox: [number, number, number, number];
    color: string;
    rects: Array<[number, number, number, number]>;
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    note?: string;
  }) {
    super(params);
    this.type = params.type;
    this.color = params.color;
    this.rects = params.rects;
    this.note = params.note;
  }
}

/**
 * Comment marker annotation for general comments
 * @ignore
 */
export class CommentMarkerAnnotation extends BaseAnnotation {
  type: 'pspdfkit/comment-marker' | 'comment-marker';
  color?: string;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/comment-marker' | 'comment-marker';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    color?: string;
  }) {
    super(params);
    this.type = params.type;
    this.color = params.color;
  }
}

/**
 * Ellipse annotation for drawing ellipses
 * @ignore
 */
export class EllipseShapeAnnotation extends ShapeAnnotation {
  type: 'pspdfkit/shape/ellipse' | 'shape/ellipse' | 'ellipse';
  cloudyBorderInset?: [number, number, number, number];
  cloudyBorderIntensity?: number;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/shape/ellipse' | 'shape/ellipse' | 'ellipse';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    cloudyBorderInset?: [number, number, number, number];
    cloudyBorderIntensity?: number;
  }) {
    super(params);
    this.type = params.type;
    this.cloudyBorderInset = params.cloudyBorderInset;
    this.cloudyBorderIntensity = params.cloudyBorderIntensity;
  }
}

/**
 * Highlight annotation for text markup
 * @ignore
 */
export class HighlightMarkupAnnotation extends MarkupAnnotation {
  type: 'pspdfkit/markup/highlight' | 'markup/highlight' | 'highlight';

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    color: string;
    rects: Array<[number, number, number, number]>;
    type: 'pspdfkit/markup/highlight' | 'markup/highlight' | 'highlight';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
  }) {
    super(params);
    this.type = params.type;
  }
}

/**
 * Image annotation for embedded images
 * @ignore
 */
export class ImageAnnotation extends BaseAnnotation {
  type: 'pspdfkit/image' | 'image';
  contentType?: string;
  description?: string;
  fileName?: string;
  imageAttachmentId?: string;
  isSignature?: boolean;
  rotation?: number;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/image' | 'image';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    contentType?: string;
    description?: string;
    fileName?: string;
    imageAttachmentId?: string;
    isSignature?: boolean;
    rotation?: number;
  }) {
    super(params);
    this.type = params.type;
    this.contentType = params.contentType;
    this.description = params.description;
    this.fileName = params.fileName;
    this.imageAttachmentId = params.imageAttachmentId;
    this.isSignature = params.isSignature ?? false;
    this.rotation = params.rotation ?? 0;
  }
}

/**
 * Ink annotation for freehand drawing
 * @ignore
 */
export class InkAnnotation extends BaseAnnotation {
  type: 'pspdfkit/ink' | 'ink';
  lines: {
    points: Array<Array<[number, number]>>;
    intensities: Array<Array<number>>;
  };
  lineWidth: number;
  strokeColor?: string;
  isDrawnNaturally: boolean;
  isSignature?: boolean;
  backgroundColor?: string;
  note?: string;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    lines: {
      points: Array<Array<[number, number]>>;
      intensities: Array<Array<number>>;
    };
    isDrawnNaturally: boolean;
    type: 'pspdfkit/ink' | 'ink';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    lineWidth?: number;
    strokeColor?: string;
    isSignature?: boolean;
    backgroundColor?: string;
    note?: string;
  }) {
    super(params);
    this.type = params.type;
    this.lines = params.lines;
    this.lineWidth = params.lineWidth ?? 5;
    this.strokeColor = params.strokeColor ?? '#0000FF';
    this.isDrawnNaturally = params.isDrawnNaturally;
    this.isSignature = params.isSignature ?? false;
    this.backgroundColor = params.backgroundColor;
    this.note = params.note;
  }
}

/**
 * Line annotation for straight lines
 * @ignore
 */
export class LineShapeAnnotation extends ShapeAnnotation {
  type: 'pspdfkit/shape/line' | 'shape/line' | 'line';
  startPoint?: [number, number];
  endPoint?: [number, number];
  lineCaps?: {
    start?: 'none' | 'square' | 'circle' | 'diamond' | 'openArrow' | 'closedArrow';
    end?: 'none' | 'square' | 'circle' | 'diamond' | 'openArrow' | 'closedArrow';
  };

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/shape/line' | 'shape/line' | 'line';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    strokeColor?: string;
    strokeWidth?: number;
    startPoint?: [number, number];
    endPoint?: [number, number];
    lineCaps?: {
      start?: 'none' | 'square' | 'circle' | 'diamond' | 'openArrow' | 'closedArrow';
      end?: 'none' | 'square' | 'circle' | 'diamond' | 'openArrow' | 'closedArrow';
    };
  }) {
    super(params);
    this.type = params.type;
    this.startPoint = params.startPoint;
    this.endPoint = params.endPoint;
    this.lineCaps = params.lineCaps;
  }
}

/**
 * Link annotation for interactive links
 * @ignore
 */
export class LinkAnnotation extends BaseAnnotation {
  type: 'pspdfkit/link' | 'link';
  borderColor?: string;
  borderStyle?: string;
  borderWidth?: number;
  note?: string;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/link' | 'link';
    action?: {
      type?: string;
      [key: string]: any;
    };
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    borderColor?: string;
    borderStyle?: 'solid' | 'dashed' | 'beveled' | 'inset' | 'underline';
    borderWidth?: number;
    note?: string;
  }) {
    super(params);
    this.type = params.type;
    this.borderColor = params.borderColor;
    this.borderStyle = params.borderStyle;
    this.borderWidth = params.borderWidth;
    this.note = params.note;
  }
}

/**
 * Note annotation for sticky notes
 * @ignore
 */
export class NoteAnnotation extends BaseAnnotation {
  type: 'pspdfkit/note' | 'note';
  color?: string;
  icon?: string;
  text?: string | {
    format: string;
    value: string;
  };

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/note' | 'note';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    color?: string;
    icon?: 'comment' | 'rightPointer' | 'rightArrow' | 'check' | 'circle' | 'cross' |
           'insert' | 'newParagraph' | 'note' | 'paragraph' | 'help' | 'star' | 'key';
    text?: string | { format: string; value: string; };
  }) {
    super(params);
    this.type = params.type;
    this.color = params.color;
    this.icon = params.icon;
    this.text = params.text;
  }
}

/**
 * Media annotation for embedded audio/video
 * @ignore
 */
export class MediaAnnotation extends BaseAnnotation {
  type: 'pspdfkit/media' | 'media';
  contentType?: string;
  fileName?: string;
  mediaAttachmentId: string;
  posterImageAttachmentId?: string;
  autoplay?: boolean;
  showControls?: boolean;
  repeat?: boolean;
  volume?: number;
  offset?: number;
  mediaSource?: string;
  encoding?: {
    bits: number;
    format: string;
    rate: number;
  };

  constructor(params: {
    pageIndex: number;
    type: 'pspdfkit/media' | 'media';
    bbox: [number, number, number, number];
    mediaAttachmentId: string;
    opacity?: number;
    contentType?: string;
    fileName?: string;
    posterImageAttachmentId?: string;
    autoplay?: boolean;
    showControls?: boolean;
    repeat?: boolean;
    volume?: number;
    offset?: number;
    mediaSource?: string;
    encoding?: {
      bits: number;
      format: string;
      rate: number;
    };
  }) {
    super(params);
    this.type = params.type;
    this.mediaAttachmentId = params.mediaAttachmentId;
    this.contentType = params.contentType;
    this.fileName = params.fileName;
    this.posterImageAttachmentId = params.posterImageAttachmentId;
    this.autoplay = params.autoplay ?? false;
    this.showControls = params.showControls ?? true;
    this.repeat = params.repeat ?? false;
    this.volume = params.volume ?? 1;
    this.offset = params.offset ?? 0;
    this.mediaSource = params.mediaSource;
    this.encoding = params.encoding;
  }
}

/**
 * Polygon annotation for closed shapes with multiple points
 * @ignore
 */
export class PolygonShapeAnnotation extends ShapeAnnotation {
  type: 'pspdfkit/shape/polygon' | 'shape/polygon' | 'polygon';
  points: Array<[number, number]>;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/shape/polygon' | 'shape/polygon' | 'polygon';
    points: Array<[number, number]>;
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    fillColor?: string;
    strokeColor?: string;
    strokeWidth?: number;
  }) {
    super(params);
    this.type = params.type;
    this.points = params.points;
  }
}

/**
 * Polyline annotation for open shapes with multiple points
 * @ignore
 */
export class PolylineShapeAnnotation extends ShapeAnnotation {
  type: 'pspdfkit/shape/polyline' | 'shape/polyline' | 'polyline';
  points: Array<[number, number]>;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/shape/polyline' | 'shape/polyline' | 'polyline';
    points: Array<[number, number]>;
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    fillColor?: string;
    strokeColor?: string;
    strokeWidth?: number;
  }) {
    super(params);
    this.type = params.type;
    this.points = params.points;
  }
}

/**
 * Rectangle annotation for drawing rectangles
 * @ignore
 */
export class RectangleShapeAnnotation extends ShapeAnnotation {
  type: 'pspdfkit/shape/rectangle' | 'shape/rectangle' | 'rectangle';
  cloudyBorderInset?: [number, number, number, number];
  cloudyBorderIntensity?: number;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/shape/rectangle' | 'shape/rectangle' | 'rectangle';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    fillColor?: string;
    strokeColor?: string;
    strokeWidth?: number;
    cloudyBorderInset?: [number, number, number, number];
    cloudyBorderIntensity?: number;
  }) {
    super(params);
    this.type = params.type;
    this.cloudyBorderInset = params.cloudyBorderInset;
    this.cloudyBorderIntensity = params.cloudyBorderIntensity;
  }
}

/**
 * Squiggly annotation for wavy underlines
 * @ignore
 */
export class SquigglyMarkupAnnotation extends MarkupAnnotation {
  type: 'pspdfkit/markup/squiggly' | 'markup/squiggly' | 'squiggly';

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/markup/squiggly' | 'markup/squiggly' | 'squiggly';
    color: string;
    rects: Array<[number, number, number, number]>;
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
  }) {
    super(params);
    this.type = params.type;
  }
}

/**
 * Redaction annotation for permanently removing content
 * @ignore
 */
export class RedactionMarkupAnnotation extends MarkupAnnotation {
  type: 'pspdfkit/markup/redaction' | 'markup/redaction' | 'redaction';
  fillColor?: string;
  overlayText?: string;
  repeatOverlayText?: boolean;
  outlineColor?: string;
  rotation?: number;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/markup/redaction' | 'markup/redaction' | 'redaction';
    color: string;
    rects: Array<[number, number, number, number]>;
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    fillColor?: string;
    overlayText?: string;
    repeatOverlayText?: boolean;
    outlineColor?: string;
    rotation?: number;
  }) {
    super(params);
    this.type = params.type;
    this.fillColor = params.fillColor;
    this.overlayText = params.overlayText;
    this.repeatOverlayText = params.repeatOverlayText;
    this.outlineColor = params.outlineColor;
    this.rotation = params.rotation;
  }
}

/**
 * Stamp annotation for adding stamps/images
 * @ignore
 */
export class StampAnnotation extends BaseAnnotation {
  type: 'pspdfkit/stamp' | 'stamp';
  imageAttachmentId?: string;
  stampType?: string;
  title?: string;
  subtitle?: string;
  color?: string;
  rotation?: number;
  subject?: string;
  size?: [number, number];
  scale?: number;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/stamp' | 'stamp';
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    imageAttachmentId?: string;
    stampType?: string;
    title?: string;
    subtitle?: string;
    color?: string;
    rotation?: number;
    subject?: string;
    size?: [number, number];
    scale?: number;
  }) {
    super(params);
    this.type = params.type;
    this.imageAttachmentId = params.imageAttachmentId;
    this.stampType = params.stampType;
    this.title = params.title;
    this.subtitle = params.subtitle;
    this.color = params.color;
    this.rotation = params.rotation;
    this.subject = params.subject;
    this.size = params.size;
    this.scale = params.scale;
  }
}

/**
 * Strike out annotation for striking through text
 * @ignore
 */
export class StrikeOutMarkupAnnotation extends MarkupAnnotation {
  type: 'pspdfkit/markup/strikeout' | 'markup/strikeout' | 'strikeout';

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/markup/strikeout' | 'markup/strikeout' | 'strikeout';
    color: string;
    rects: Array<[number, number, number, number]>;
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
  }) {
    super(params);
    this.type = params.type;
  }
}

/**
 * Text annotation for adding text boxes
 * @ignore
 */
export class TextAnnotation extends BaseAnnotation {
  type: 'pspdfkit/text' | 'text';
  text: string | { format: string; value: string };
  fontSize: number;
  fontColor: string;
  fontFamily?: string;
  fontWeight?: string;
  fontStyle?: string[];
  textDecorationLine?: string;
  textDecorationStyle?: string;
  textDecorationColor?: string;
  horizontalAlign?: 'left' | 'center' | 'right';
  verticalAlign?: 'top' | 'center' | 'bottom';
  characterSpacing?: number;
  lineHeight?: number;
  backgroundColor?: string;
  borderStyle?: string;
  borderDashArray?: Array<number>;
  borderWidth?: number;
  rotation?: number;
  cloudyBorderIntensity?: number;
  cloudyBorderInset?: [number, number, number, number];
  isFitting?: boolean;
  callout?: {
    start: [number, number];
    knee?: [number, number];
    end: [number, number];
    innerRectInset: [number, number, number, number];
  };
  font?: string;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/text' | 'text';
    text: string | { format: string; value: string };
    fontSize: number;
    fontColor: string;
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
    fontFamily?: string;
    fontWeight?: string;
    fontStyle?: string[];
    textDecorationLine?: string;
    textDecorationStyle?: string;
    textDecorationColor?: string;
    horizontalAlign?: 'left' | 'center' | 'right';
    verticalAlign?: 'top' | 'center' | 'bottom';
    characterSpacing?: number;
    lineHeight?: number;
    backgroundColor?: string;
    borderStyle?: string;
    borderDashArray?: Array<number>;
    borderWidth?: number;
    rotation?: number;
    cloudyBorderIntensity?: number;
    cloudyBorderInset?: [number, number, number, number];
    isFitting?: boolean;
    callout?: {
      start: [number, number];
      knee?: [number, number];
      end: [number, number];
      innerRectInset: [number, number, number, number];
    };
    font?: string;
  }) {
    super(params);
    this.type = params.type;
    this.text = params.text;
    this.fontSize = params.fontSize;
    this.fontColor = params.fontColor;
    this.fontFamily = params.fontFamily;
    this.fontWeight = params.fontWeight;
    this.fontStyle = params.fontStyle;
    this.textDecorationLine = params.textDecorationLine;
    this.textDecorationStyle = params.textDecorationStyle;
    this.textDecorationColor = params.textDecorationColor;
    this.horizontalAlign = params.horizontalAlign;
    this.verticalAlign = params.verticalAlign;
    this.characterSpacing = params.characterSpacing;
    this.lineHeight = params.lineHeight;
    this.backgroundColor = params.backgroundColor;
    this.borderStyle = params.borderStyle;
    this.borderDashArray = params.borderDashArray;
    this.borderWidth = params.borderWidth;
    this.rotation = params.rotation;
    this.cloudyBorderIntensity = params.cloudyBorderIntensity;
    this.cloudyBorderInset = params.cloudyBorderInset;
    this.isFitting = params.isFitting;
    this.callout = params.callout;
    this.font = params.font;
  }
}

/**
 * Underline annotation for underlining text
 * @ignore
 */
export class UnderlineMarkupAnnotation extends MarkupAnnotation {
  type: 'pspdfkit/markup/underline' | 'markup/underline' | 'underline';

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/markup/underline' | 'markup/underline' | 'underline';
    color: string;
    rects: Array<[number, number, number, number]>;
    opacity?: number;
    v?: number;
    blendMode?: string;
    hidden?: boolean;
    locked?: boolean;
    lockedContents?: boolean;
    noPrint?: boolean;
    noView?: boolean;
    readOnly?: boolean;
    uuid?: string;
    id?: string;
    name?: string;
    createdAt?: string;
    updatedAt?: string;
    creatorName?: string;
    pdfObjectId?: number;
    flags?: Array<string>;
    customData?: Object;
  }) {
    super(params);
    this.type = params.type;
  }
}

/**
 * Widget annotation for form fields
 * @ignore
 */
export class WidgetAnnotation extends BaseAnnotation {
  type: 'pspdfkit/widget' | 'widget';
  horizontalAlign: 'left' | 'center' | 'right';
  verticalAlign: 'top' | 'center' | 'bottom';
  formFieldName?: string;
  font?: string;
  fontColor?: string;
  fontSize?: number;
  fieldType?: string;
  fieldValue?: string | number | boolean;
  defaultValue?: string | number | boolean;
  placeholder?: string;
  maxLength?: number;
  isMultiline?: boolean;
  isPassword?: boolean;
  choices?: string[];
  isReadOnly?: boolean;
  isRequired?: boolean;
  isEditable?: boolean;
  rotation?: number;
  backgroundColor?: string;
  borderColor?: string;
  borderStyle?: string;
  borderWidth?: number;
  additionalActions?: {
    onFormat?: { script: string; type: string; };
    onInput?: { script: string; type: string; };
  };
  isBold?: boolean;
  isItalic?: boolean;
  formElement?: FormElement;

  constructor(params: {
    pageIndex: number;
    bbox: [number, number, number, number];
    type: 'pspdfkit/widget' | 'widget';
    horizontalAlign: 'left' | 'center' | 'right';
    verticalAlign: 'top' | 'center' | 'bottom';
    opacity?: number;
    formFieldName?: string;
    font?: string;
    fontColor?: string;
    fontSize?: number;
    fieldType?: string;
    fieldValue?: string | number | boolean;
    defaultValue?: string | number | boolean;
    placeholder?: string;
    maxLength?: number;
    isMultiline?: boolean;
    isPassword?: boolean;
    choices?: string[];
    isReadOnly?: boolean;
    isRequired?: boolean;
    isEditable?: boolean;
    rotation?: number;
    backgroundColor?: string;
    borderColor?: string;
    borderStyle?: string;
    borderWidth?: number;
    additionalActions?: {
      onFormat?: { script: string; type: string; };
      onInput?: { script: string; type: string; };
    };
    isBold?: boolean;
    isItalic?: boolean;
    formElement?: FormElement;
  }) {
    super(params);
    this.type = params.type;
    this.horizontalAlign = params.horizontalAlign ?? 'left';
    this.verticalAlign = params.verticalAlign;
    this.formFieldName = params.formFieldName;
    this.font = params.font;
    this.fontColor = params.fontColor;
    this.fontSize = params.fontSize;
    this.fieldType = params.fieldType;
    this.fieldValue = params.fieldValue;
    this.defaultValue = params.defaultValue;
    this.placeholder = params.placeholder;
    this.maxLength = params.maxLength;
    this.isMultiline = params.isMultiline;
    this.isPassword = params.isPassword;
    this.choices = params.choices;
    this.isReadOnly = params.isReadOnly;
    this.isRequired = params.isRequired;
    this.isEditable = params.isEditable;
    this.rotation = params.rotation ?? 0;
    this.backgroundColor = params.backgroundColor;
    this.borderColor = params.borderColor;
    this.borderStyle = params.borderStyle;
    this.borderWidth = params.borderWidth;
    this.additionalActions = params.additionalActions;
    this.isBold = params.isBold ?? false;
    this.isItalic = params.isItalic ?? false;
    this.formElement = params.formElement;
  }
}

/**
 * Union type of all annotation types
 * @ignore
 */
export type AnnotationType =
  | CommentMarkerAnnotation
  | EllipseShapeAnnotation
  | HighlightMarkupAnnotation
  | ImageAnnotation
  | InkAnnotation
  | LineShapeAnnotation
  | LinkAnnotation
  | MediaAnnotation
  | NoteAnnotation
  | PolygonShapeAnnotation
  | PolylineShapeAnnotation
  | RectangleShapeAnnotation
  | RedactionMarkupAnnotation
  | SquigglyMarkupAnnotation
  | StampAnnotation
  | StrikeOutMarkupAnnotation
  | TextAnnotation
  | UnderlineMarkupAnnotation
  | WidgetAnnotation;
